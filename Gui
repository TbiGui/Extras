local AdoptMeConfigs = {}
AdoptMeConfigs.__index = AdoptMeConfigs

local LocalPlayer = game.Players.LocalPlayer

local getiden = getthreadidentity or getidentity
local setiden = setthreadidentity or setidentity

ClientData = require(game:GetService("ReplicatedStorage").ClientModules.Core.ClientData)
RouterClient = require(game:GetService("ReplicatedStorage").ClientModules.Core.RouterClient.RouterClient)

function AdoptMeConfigs.getLastSegment(path)
	return string.match(path, ".*/(.*)")
end

function AdoptMeConfigs.GetPlayersInventory()
	return ClientData.get_data()[LocalPlayer.Name].inventory
end

function AdoptMeConfigs.GetAilmentsManager()
	return ClientData.get_server(LocalPlayer,"ailments_manager")
end

function AdoptMeConfigs.GetPetPetEntityManager()
	return require(game:GetService("ReplicatedStorage").ClientModules.Game.PetEntities.PetEntityManager)
end

function AdoptMeConfigs.InventoryDB()
	return require(game:GetService("ReplicatedStorage").ClientDB.Inventory.InventoryDB)
end

function AdoptMeConfigs.GetCertificate()
	return ClientData.get("subscription_manager").equip_2x_pets.active
end

local Location
for i, v in next, getgc() do
	if type(v) == "function" and islclosure(v) and table.find(getconstants(v), "LocationAPI/SetLocation") then
		Location = v
		break
	end
end

local function SetLocation(A, B, C)
	local old = getiden()
	setiden(2)
	Location(A, B, C)
	setiden(old)
end

local function GetInteriorModel()
	return workspace.Interiors:FindFirstChildWhichIsA("Model")
end

local function Store()
	local storeModel = GetInteriorModel()
	return (storeModel and not storeModel.Name:find("MainMap") and not storeModel.Name:find("Neighborhood")) and storeModel.Name or false
end

local function GetHomeModel()
	return workspace.HouseInteriors.blueprint:FindFirstChildWhichIsA("Model")
end

local function Home()
	local homeModel = GetHomeModel()
	return homeModel and homeModel.Name or false
end

local function MainMap()
	local mapModel = GetInteriorModel()
	return (mapModel and mapModel.Name:find("MainMap")) and mapModel.Name or false
end

local function Neighborhood()
	local neighborhoodModel = GetInteriorModel()
	return (neighborhoodModel and neighborhoodModel.Name:find("Neighborhood")) and neighborhoodModel.Name or false
end

local function TeleportAndWait(LocationName, Door, Params, Condition)
	SetLocation(LocationName, Door, Params)
	return true
end

function AdoptMeConfigs.GoToStore(Name)
	if Store() == Name then return true end
	return TeleportAndWait(Name, "MainDoor", {}, function() return Store() == Name end)
end

function AdoptMeConfigs.GoToMainMap()
	return TeleportAndWait("MainMap", "Neighborhood/MainDoor", {}, MainMap)
end

function AdoptMeConfigs.GoToHome()
	return TeleportAndWait("housing", "MainDoor", {["house_owner"] = LocalPlayer}, Home)
end

function AdoptMeConfigs.GoToNeighborhood()
	return TeleportAndWait("Neighborhood", "MainDoor", {}, Neighborhood)
end

function AdoptMeConfigs.RunRouterClient(IsFire, RouterName, args)
	local old = getiden()
	setiden(2)
	if IsFire then
		if args then
			RouterClient.get(RouterName):FireServer(unpack(args))
		else
			RouterClient.get(RouterName):FireServer()
		end
	else
		if args then
			RouterClient.get(RouterName):InvokeServer(unpack(args))	
		else
			RouterClient.get(RouterName):InvokeServer()	
		end
	end
	setiden(old)
end

function AdoptMeConfigs.SetPlayerToParent()
	local args = {
		[1] = "Parents",
		[2] = {
			["dont_respawn"] = true,
			["source_for_logging"] = "avatar_editor"
		}
	}

	AdoptMeConfigs.RunRouterClient(false, "TeamAPI/ChooseTeam", args)
end

function AdoptMeConfigs.SetPlayerToBaby()
	local args = {
		[1] = "Babies",
		[2] = {
			["dont_respawn"] = true,
			["source_for_logging"] = "avatar_editor"
		}
	}
	AdoptMeConfigs.RunRouterClient(false, "TeamAPI/ChooseTeam", args)
end

function AdoptMeConfigs.GetPlayersPetConfigs(PetUnique)
	local PetConfigs = {
		petKind = "",
		petAge = ""
	}
	
	for i,v in pairs(AdoptMeConfigs.GetPlayersInventory().pets) do
		if i == PetUnique then
			PetConfigs.petKind = v.kind or ""
			PetConfigs.petAge = v.properties.age or 1
			break
		end
	end
	
	return PetConfigs
end

function AdoptMeConfigs.GetPetConfigs(PetKind)
	local PetConfigs = {
		isEgg = false,
	}
	
	for i,v in pairs(AdoptMeConfigs.InventoryDB().pets) do
		if i == PetKind then
			PetConfigs.isEgg = v.is_egg or false
			break
		end
	end
	
	return PetConfigs
end

function AdoptMeConfigs.GetPlayersEquippedPets()
	return ClientData.get_data()[game.Players.LocalPlayer.Name].equip_manager.pets
end

function AdoptMeConfigs.GetCurrentPet(PetUnique)	
	local CurrentPet = {}
	
	for _,v in pairs(AdoptMeConfigs.GetPetPetEntityManager().get_local_owned_pet_entities()) do
		if v.unique_id == PetUnique then
			CurrentPet = v
			break
		end
	end
	
	return CurrentPet
end

function AdoptMeConfigs.GetAilments(PetUnique1, PetUnique2, DisabledAilments)
	local Ailments = {
		["FirstPet"] = {},
		["SecondPet"] = {},
		["Baby"] = {},	
	}
	
	local AilmentsManager = AdoptMeConfigs.GetAilmentsManager()
	local PetAilments = AilmentsManager.ailments
	local BabyAilments = AilmentsManager.baby_ailments
	
	Ailments.Baby = BabyAilments or {}
	
	for i,v in pairs(PetAilments) do
		if not PetUnique1 and not PetUnique2 then
			break
		end
		if i == PetUnique1 then
			for i2,v2 in pairs(v) do
				if DisabledAilments and not table.find(DisabledAilments, v2.kind) then
					Ailments.FirstPet[v2.kind] = {}
				end
			end
			elseif i == PetUnique2 then
			for i2,v2 in pairs(v) do
				if DisabledAilments and not table.find(DisabledAilments, v2.kind) then
					Ailments.SecondPet[v2.kind] = {}
				end
			end
		end
	end
	
	return Ailments
end

function AdoptMeConfigs.EquipPet(PetUnique)
	local args = {
		[1] = PetUnique,
		[2] = {
			["equip_as_last"] = false,
			["use_sound_delay"] = true
		}
	}
	AdoptMeConfigs.RunRouterClient(false, "ToolAPI/Equip", args)
end

function AdoptMeConfigs.UnequipPet(PetUnique)
	local args = {
		[1] = PetUnique,
		[2] = {
			["equip_as_last"] = false,
			["use_sound_delay"] = true
		}
	}
	AdoptMeConfigs.RunRouterClient(false, "ToolAPI/Unequip", args)
end

function AdoptMeConfigs.UnequipAllPets()
	for _,v in pairs(AdoptMeConfigs.GetPlayersEquippedPets()) do
		if v.unique then
			AdoptMeConfigs.UnequipPet(v.unique)
		end
	end
end

function AdoptMeConfigs.GetFurniture(Furniture)
		local HouseInteriorsNew = workspace:WaitForChild("HouseInteriors")
		for i,v in pairs(HouseInteriorsNew:WaitForChild("furniture"):GetChildren()) do
			task.wait()
			for i2,v2 in pairs(v:GetChildren()) do
				task.wait() 
				if v2.Name == Furniture then
					return AdoptMeConfigs.getLastSegment(v.Name)
				end
			end
		end
	return false
end

function AdoptMeConfigs.IsEggNotThere(EggUnique)
	local IsEggThere = false
	local Success, Err = pcall(function()
		for i,v in pairs(AdoptMeConfigs.GetPlayersInventory().pets) do
			task.wait()
			if i == EggUnique then
				IsEggThere = true
				break
			else
				IsEggThere = false
			end
		end
	end)

	if not Success then
		warn("Something went wrong while checking if egg is still there: " .. Err)
		return false
	else
		if IsEggThere then
			return false
		else
			return true
		end
	end
end

function AdoptMeConfigs.GetSameKind(PetUnique, PetKind)
	for i,v in pairs(AdoptMeConfigs.GetPlayersInventory().pets) do
		if i == PetUnique then
			continue
		end
		
		if v.kind == PetKind then
			return i
		end
	end
end

function AdoptMeConfigs.GetRandomKind(PetUnique)
	for i,v in pairs(AdoptMeConfigs.GetPlayersInventory().pets) do
		if i == PetUnique then
			continue
		end
		
		local PetConfigs = AdoptMeConfigs.GetPetConfigs(AdoptMeConfigs.GetPlayersPetConfigs(PetUnique).petKind)
		local PetToSearch = AdoptMeConfigs.GetPetConfigs(v.kind)
		
		if PetConfigs.isEgg and PetToSearch.isEgg then
			return i
		elseif not PetConfigs.isEgg and not PetToSearch.isEgg then
			return i
		end
	end
end

return AdoptMeConfigs
